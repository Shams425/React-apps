{"ast":null,"code":"import _toConsumableArray from \"/home/abdallah/Documents/React-apps/DashBoard-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nvar _excluded = [\"rowsBeforePartialUpdates\"];\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\n\nexport function checkGridRowIdIsValid(id, row) {\n  var detailErrorMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'A row was provided without id in the rows prop:';\n\n  if (id == null) {\n    throw new Error(['MUI: The data grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nexport var getRowIdFromRowModel = function getRowIdFromRowModel(rowModel, getRowId, detailErrorMessage) {\n  var id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexport var createRowsInternalCache = function createRowsInternalCache(_ref) {\n  var rows = _ref.rows,\n      getRowId = _ref.getRowId,\n      loading = _ref.loading;\n  var cache = {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    idRowsLookup: {},\n    idToIdLookup: {},\n    ids: []\n  };\n\n  for (var i = 0; i < rows.length; i += 1) {\n    var row = rows[i];\n    var id = getRowIdFromRowModel(row, getRowId);\n    cache.idRowsLookup[id] = row;\n    cache.idToIdLookup[id] = id;\n    cache.ids.push(id);\n  }\n\n  return cache;\n};\nexport var getRowsStateFromCache = function getRowsStateFromCache(_ref2) {\n  var apiRef = _ref2.apiRef,\n      previousTree = _ref2.previousTree,\n      rowCountProp = _ref2.rowCountProp,\n      loadingProp = _ref2.loadingProp;\n\n  var _apiRef$current$unsta = apiRef.current.unstable_caches.rows,\n      cacheForGrouping = _objectWithoutPropertiesLoose(_apiRef$current$unsta, _excluded);\n\n  var rowCount = rowCountProp != null ? rowCountProp : 0;\n  var groupingResponse = apiRef.current.unstable_applyStrategyProcessor('rowTreeCreation', _extends({}, cacheForGrouping, {\n    previousTree: previousTree\n  }));\n  var processedGroupingResponse = apiRef.current.unstable_applyPipeProcessors('hydrateRows', groupingResponse);\n  var dataTopLevelRowCount = processedGroupingResponse.treeDepth === 1 ? processedGroupingResponse.ids.length : Object.values(processedGroupingResponse.tree).filter(function (node) {\n    return node.parent == null;\n  }).length;\n  return _extends({}, processedGroupingResponse, {\n    groupingResponseBeforeRowHydration: groupingResponse,\n    loading: loadingProp,\n    totalRowCount: Math.max(rowCount, processedGroupingResponse.ids.length),\n    totalTopLevelRowCount: Math.max(rowCount, dataTopLevelRowCount)\n  });\n};\nexport var getTreeNodeDescendants = function getTreeNodeDescendants(tree, parentId, skipAutoGeneratedRows) {\n  var _tree$parentId;\n\n  var children = (_tree$parentId = tree[parentId]) == null ? void 0 : _tree$parentId.children;\n\n  if (children == null) {\n    return [];\n  }\n\n  var validDescendants = [];\n\n  for (var i = 0; i < children.length; i += 1) {\n    var child = children[i];\n    var childNode = tree[child];\n\n    if (!skipAutoGeneratedRows || !childNode.isAutoGenerated) {\n      validDescendants.push(child);\n    }\n\n    validDescendants.push.apply(validDescendants, _toConsumableArray(getTreeNodeDescendants(tree, childNode.id, skipAutoGeneratedRows)));\n  }\n\n  return validDescendants;\n};","map":null,"metadata":{},"sourceType":"module"}