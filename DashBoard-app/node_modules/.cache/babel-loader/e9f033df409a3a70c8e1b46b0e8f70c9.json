{"ast":null,"code":"import _slicedToArray from \"/home/abdallah/Documents/React-apps/DashBoard-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nvar _excluded = [\"colDef\", \"id\", \"api\", \"hasFocus\", \"isEditable\", \"field\", \"value\", \"formattedValue\", \"row\", \"rowNode\", \"cellMode\", \"getValue\", \"tabIndex\", \"position\", \"focusElementRef\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport IconButton from '@mui/material/IconButton';\nimport MenuList from '@mui/material/MenuList';\nimport { unstable_useId as useId } from '@mui/material/utils';\nimport { gridClasses } from '../../constants/gridClasses';\nimport { GridMenu } from '../menu/GridMenu';\nimport { useGridRootProps } from '../../hooks/utils/useGridRootProps';\nimport { useGridApiContext } from '../../hooks/utils/useGridApiContext';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\nvar hasActions = function hasActions(colDef) {\n  return typeof colDef.getActions === 'function';\n};\n\nvar GridActionsCell = function GridActionsCell(props) {\n  var colDef = props.colDef,\n      id = props.id,\n      hasFocus = props.hasFocus,\n      tabIndex = props.tabIndex,\n      _props$position = props.position,\n      position = _props$position === void 0 ? 'bottom-end' : _props$position,\n      focusElementRef = props.focusElementRef,\n      other = _objectWithoutPropertiesLoose(props, _excluded);\n\n  var _React$useState = React.useState(-1),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      focusedButtonIndex = _React$useState2[0],\n      setFocusedButtonIndex = _React$useState2[1];\n\n  var _React$useState3 = React.useState(false),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      open = _React$useState4[0],\n      setOpen = _React$useState4[1];\n\n  var apiRef = useGridApiContext();\n  var rootRef = React.useRef(null);\n  var buttonRef = React.useRef(null);\n  var ignoreCallToFocus = React.useRef(false);\n  var touchRippleRefs = React.useRef({});\n  var menuId = useId();\n  var buttonId = useId();\n  var rootProps = useGridRootProps();\n  React.useLayoutEffect(function () {\n    if (!hasFocus) {\n      Object.entries(touchRippleRefs.current).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            index = _ref2[0],\n            ref = _ref2[1];\n\n        ref == null ? void 0 : ref.stop({}, function () {\n          delete touchRippleRefs.current[index];\n        });\n      });\n    }\n  }, [hasFocus]);\n  React.useEffect(function () {\n    if (focusedButtonIndex < 0 || !rootRef.current) {\n      return;\n    }\n\n    if (focusedButtonIndex >= rootRef.current.children.length) {\n      return;\n    }\n\n    var child = rootRef.current.children[focusedButtonIndex];\n    child.focus();\n  }, [focusedButtonIndex]);\n  React.useEffect(function () {\n    if (!hasFocus) {\n      setFocusedButtonIndex(-1);\n      ignoreCallToFocus.current = false;\n    }\n  }, [hasFocus]);\n  React.useImperativeHandle(focusElementRef, function () {\n    return {\n      focus: function focus() {\n        // If ignoreCallToFocus is true, then one of the buttons was clicked and the focus is already set\n        if (!ignoreCallToFocus.current) {\n          setFocusedButtonIndex(0);\n        }\n      }\n    };\n  }, []);\n\n  if (!hasActions(colDef)) {\n    throw new Error('MUI: Missing the `getActions` property in the `GridColDef`.');\n  }\n\n  var options = colDef.getActions(apiRef.current.getRowParams(id));\n  var iconButtons = options.filter(function (option) {\n    return !option.props.showInMenu;\n  });\n  var menuButtons = options.filter(function (option) {\n    return option.props.showInMenu;\n  });\n  var numberOfButtons = iconButtons.length + (menuButtons.length ? 1 : 0);\n  React.useEffect(function () {\n    if (focusedButtonIndex >= numberOfButtons) {\n      setFocusedButtonIndex(numberOfButtons - 1);\n    }\n  }, [focusedButtonIndex, numberOfButtons]);\n\n  var showMenu = function showMenu() {\n    setOpen(true);\n    setFocusedButtonIndex(numberOfButtons - 1);\n    ignoreCallToFocus.current = true;\n  };\n\n  var hideMenu = function hideMenu() {\n    setOpen(false);\n  };\n\n  var handleTouchRippleRef = function handleTouchRippleRef(index) {\n    return function (instance) {\n      touchRippleRefs.current[index] = instance;\n    };\n  };\n\n  var handleButtonClick = function handleButtonClick(index, onClick) {\n    return function (event) {\n      setFocusedButtonIndex(index);\n      ignoreCallToFocus.current = true;\n\n      if (onClick) {\n        onClick(event);\n      }\n    };\n  };\n\n  var handleRootKeyDown = function handleRootKeyDown(event) {\n    if (numberOfButtons <= 1) {\n      return;\n    }\n\n    var newIndex = focusedButtonIndex;\n\n    if (event.key === 'ArrowRight') {\n      newIndex += 1;\n    } else if (event.key === 'ArrowLeft') {\n      newIndex -= 1;\n    }\n\n    if (newIndex < 0 || newIndex >= numberOfButtons) {\n      return; // We're already in the first or last item = do nothing and let the grid listen the event\n    }\n\n    if (newIndex !== focusedButtonIndex) {\n      event.preventDefault(); // Prevent scrolling\n\n      event.stopPropagation(); // Don't stop propagation for other keys, e.g. ArrowUp\n\n      setFocusedButtonIndex(newIndex);\n    }\n  };\n\n  var handleListKeyDown = function handleListKeyDown(event) {\n    if (event.key === 'Tab') {\n      event.preventDefault();\n    }\n\n    if (['Tab', 'Enter', 'Escape'].includes(event.key)) {\n      hideMenu();\n    }\n  };\n\n  return /*#__PURE__*/_jsxs(\"div\", _extends({\n    role: \"menu\",\n    ref: rootRef,\n    tabIndex: -1,\n    className: gridClasses.actionsCell,\n    onKeyDown: handleRootKeyDown\n  }, other, {\n    children: [iconButtons.map(function (button, index) {\n      return /*#__PURE__*/React.cloneElement(button, {\n        key: index,\n        touchRippleRef: handleTouchRippleRef(index),\n        onClick: handleButtonClick(index, button.props.onClick),\n        tabIndex: focusedButtonIndex === index ? tabIndex : -1\n      });\n    }), menuButtons.length > 0 && buttonId && /*#__PURE__*/_jsx(IconButton, {\n      ref: buttonRef,\n      id: buttonId,\n      \"aria-label\": apiRef.current.getLocaleText('actionsCellMore'),\n      \"aria-controls\": menuId,\n      \"aria-expanded\": open ? 'true' : undefined,\n      \"aria-haspopup\": \"true\",\n      role: \"menuitem\",\n      size: \"small\",\n      onClick: showMenu,\n      touchRippleRef: handleTouchRippleRef(buttonId),\n      tabIndex: focusedButtonIndex === iconButtons.length ? tabIndex : -1,\n      children: /*#__PURE__*/_jsx(rootProps.components.MoreActionsIcon, {\n        fontSize: \"small\"\n      })\n    }), menuButtons.length > 0 && /*#__PURE__*/_jsx(GridMenu, {\n      onClickAway: hideMenu,\n      onClick: hideMenu,\n      open: open,\n      target: buttonRef.current,\n      position: position,\n      children: /*#__PURE__*/_jsx(MenuList, {\n        id: menuId,\n        className: gridClasses.menuList,\n        onKeyDown: handleListKeyDown,\n        \"aria-labelledby\": buttonId,\n        variant: \"menu\",\n        autoFocusItem: true,\n        children: menuButtons.map(function (button, index) {\n          return /*#__PURE__*/React.cloneElement(button, {\n            key: index\n          });\n        })\n      })\n    })]\n  }));\n};\n\nprocess.env.NODE_ENV !== \"production\" ? GridActionsCell.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n\n  /**\n   * GridApi that let you manipulate the grid.\n   * @deprecated Use the `apiRef` returned by `useGridApiContext` or `useGridApiRef` (only available in `@mui/x-data-grid-pro`)\n   */\n  api: PropTypes.any.isRequired,\n\n  /**\n   * The mode of the cell.\n   */\n  cellMode: PropTypes.oneOf(['edit', 'view']).isRequired,\n\n  /**\n   * The column of the row that the current cell belongs to.\n   */\n  colDef: PropTypes.object.isRequired,\n\n  /**\n   * The column field of the cell that triggered the event.\n   */\n  field: PropTypes.string.isRequired,\n\n  /**\n   * A ref allowing to set imperative focus.\n   * It can be passed to the element that should receive focus.\n   * @ignore - do not document.\n   */\n  focusElementRef: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({\n    current: PropTypes.shape({\n      focus: PropTypes.func.isRequired\n    })\n  })]),\n  formattedValue: PropTypes.any,\n\n  /**\n   * Get the cell value of a row and field.\n   * @param {GridRowId} id The row id.\n   * @param {string} field The field.\n   * @returns {any} The cell value.\n   * @deprecated Use `params.row` to directly access the fields you want instead.\n   */\n  getValue: PropTypes.func.isRequired,\n\n  /**\n   * If true, the cell is the active element.\n   */\n  hasFocus: PropTypes.bool.isRequired,\n\n  /**\n   * The grid row id.\n   */\n  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n\n  /**\n   * If true, the cell is editable.\n   */\n  isEditable: PropTypes.bool,\n  position: PropTypes.oneOf(['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),\n\n  /**\n   * The row model of the row that the current cell belongs to.\n   */\n  row: PropTypes.object.isRequired,\n\n  /**\n   * The node of the row that the current cell belongs to.\n   */\n  rowNode: PropTypes.object.isRequired,\n\n  /**\n   * the tabIndex value.\n   */\n  tabIndex: PropTypes.oneOf([-1, 0]).isRequired,\n  value: PropTypes.any\n} : void 0;\nexport { GridActionsCell };\nexport var renderActionsCell = function renderActionsCell(params) {\n  return /*#__PURE__*/_jsx(GridActionsCell, _extends({}, params));\n};","map":null,"metadata":{},"sourceType":"module"}