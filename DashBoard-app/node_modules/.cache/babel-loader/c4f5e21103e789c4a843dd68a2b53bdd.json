{"ast":null,"code":"import _toConsumableArray from \"/home/abdallah/Documents/React-apps/DashBoard-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridFeatureModeConstant } from '../../../models/gridFeatureMode';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridFilterableColumnLookupSelector } from '../columns/gridColumnsSelector';\nimport { GridPreferencePanelsValue } from '../preferencesPanel/gridPreferencePanelsValue';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { gridFilterModelSelector, gridVisibleSortedRowEntriesSelector } from './gridFilterSelector';\nimport { useFirstRender } from '../../utils/useFirstRender';\nimport { gridRowIdsSelector } from '../rows';\nimport { useGridRegisterPipeProcessor } from '../../core/pipeProcessing';\nimport { GRID_DEFAULT_STRATEGY, useGridRegisterStrategyProcessor } from '../../core/strategyProcessing';\nimport { buildAggregatedFilterApplier, sanitizeFilterModel, mergeStateWithFilterModel } from './gridFilterUtils';\nimport { isDeepEqual } from '../../../utils/utils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport var filterStateInitializer = function filterStateInitializer(state, props, apiRef) {\n  var _ref, _props$filterModel, _props$initialState, _props$initialState$f;\n\n  var filterModel = (_ref = (_props$filterModel = props.filterModel) != null ? _props$filterModel : (_props$initialState = props.initialState) == null ? void 0 : (_props$initialState$f = _props$initialState.filter) == null ? void 0 : _props$initialState$f.filterModel) != null ? _ref : getDefaultGridFilterModel();\n  return _extends({}, state, {\n    filter: {\n      filterModel: sanitizeFilterModel(filterModel, props.disableMultipleColumnsFiltering, apiRef),\n      visibleRowsLookup: {},\n      filteredDescendantCountLookup: {}\n    }\n  });\n};\n/**\n * @requires useGridColumns (method, event)\n * @requires useGridParamsApi (method)\n * @requires useGridRows (event)\n */\n\nexport var useGridFilter = function useGridFilter(apiRef, props) {\n  var _props$componentsProp2;\n\n  var logger = useGridLogger(apiRef, 'useGridFilter');\n  apiRef.current.unstable_updateControlState({\n    stateId: 'filter',\n    propModel: props.filterModel,\n    propOnChange: props.onFilterModelChange,\n    stateSelector: gridFilterModelSelector,\n    changeEvent: 'filterModelChange'\n  });\n  var updateFilteredRows = React.useCallback(function () {\n    apiRef.current.setState(function (state) {\n      var filterModel = gridFilterModelSelector(state, apiRef.current.instanceId);\n      var isRowMatchingFilters = props.filterMode === GridFeatureModeConstant.client ? buildAggregatedFilterApplier(filterModel, apiRef) : null;\n      var filteringResult = apiRef.current.unstable_applyStrategyProcessor('filtering', {\n        isRowMatchingFilters: isRowMatchingFilters\n      });\n      return _extends({}, state, {\n        filter: _extends({}, state.filter, filteringResult)\n      });\n    });\n    apiRef.current.publishEvent('filteredRowsSet');\n  }, [props.filterMode, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  var applyFilters = React.useCallback(function () {\n    updateFilteredRows();\n    apiRef.current.forceUpdate();\n  }, [apiRef, updateFilteredRows]);\n  var upsertFilterItem = React.useCallback(function (item) {\n    var filterModel = gridFilterModelSelector(apiRef);\n\n    var items = _toConsumableArray(filterModel.items);\n\n    var itemIndex = items.findIndex(function (filterItem) {\n      return filterItem.id === item.id;\n    });\n\n    if (itemIndex === -1) {\n      items.push(item);\n    } else {\n      items[itemIndex] = item;\n    }\n\n    apiRef.current.setFilterModel(_extends({}, filterModel, {\n      items: items\n    }));\n  }, [apiRef]);\n  var deleteFilterItem = React.useCallback(function (itemToDelete) {\n    var filterModel = gridFilterModelSelector(apiRef);\n    var items = filterModel.items.filter(function (item) {\n      return item.id !== itemToDelete.id;\n    });\n\n    if (items.length === filterModel.items.length) {\n      return;\n    }\n\n    apiRef.current.setFilterModel(_extends({}, filterModel, {\n      items: items\n    }));\n  }, [apiRef]);\n  var showFilterPanel = React.useCallback(function (targetColumnField) {\n    logger.debug('Displaying filter panel');\n\n    if (targetColumnField) {\n      var filterModel = gridFilterModelSelector(apiRef);\n      var filterItemsWithValue = filterModel.items.filter(function (item) {\n        return item.value !== undefined;\n      });\n      var newFilterItems;\n      var filterItemOnTarget = filterItemsWithValue.find(function (item) {\n        return item.columnField === targetColumnField;\n      });\n\n      if (filterItemOnTarget) {\n        newFilterItems = filterItemsWithValue;\n      } else if (props.disableMultipleColumnsFiltering) {\n        newFilterItems = [{\n          columnField: targetColumnField\n        }];\n      } else {\n        newFilterItems = [].concat(_toConsumableArray(filterItemsWithValue), [{\n          columnField: targetColumnField\n        }]);\n      }\n\n      apiRef.current.setFilterModel(_extends({}, filterModel, {\n        items: newFilterItems\n      }));\n    }\n\n    apiRef.current.showPreferences(GridPreferencePanelsValue.filters);\n  }, [apiRef, logger, props.disableMultipleColumnsFiltering]);\n  var hideFilterPanel = React.useCallback(function () {\n    logger.debug('Hiding filter panel');\n    apiRef.current.hidePreferences();\n  }, [apiRef, logger]);\n  var setFilterLinkOperator = React.useCallback(function (linkOperator) {\n    var filterModel = gridFilterModelSelector(apiRef);\n\n    if (filterModel.linkOperator === linkOperator) {\n      return;\n    }\n\n    apiRef.current.setFilterModel(_extends({}, filterModel, {\n      linkOperator: linkOperator\n    }));\n  }, [apiRef]);\n  var setQuickFilterValues = React.useCallback(function (values) {\n    var filterModel = gridFilterModelSelector(apiRef);\n\n    if (isDeepEqual(filterModel.quickFilterValues, values)) {\n      return;\n    }\n\n    apiRef.current.setFilterModel(_extends({}, filterModel, {\n      quickFilterValues: _toConsumableArray(values)\n    }));\n  }, [apiRef]);\n  var setFilterModel = React.useCallback(function (model) {\n    var currentModel = gridFilterModelSelector(apiRef);\n\n    if (currentModel !== model) {\n      logger.debug('Setting filter model');\n      apiRef.current.setState(mergeStateWithFilterModel(model, props.disableMultipleColumnsFiltering, apiRef));\n      apiRef.current.unstable_applyFilters();\n    }\n  }, [apiRef, logger, props.disableMultipleColumnsFiltering]);\n  var getVisibleRowModels = React.useCallback(function () {\n    var visibleSortedRows = gridVisibleSortedRowEntriesSelector(apiRef);\n    return new Map(visibleSortedRows.map(function (row) {\n      return [row.id, row.model];\n    }));\n  }, [apiRef]);\n  var filterApi = {\n    setFilterLinkOperator: setFilterLinkOperator,\n    unstable_applyFilters: applyFilters,\n    deleteFilterItem: deleteFilterItem,\n    upsertFilterItem: upsertFilterItem,\n    setFilterModel: setFilterModel,\n    showFilterPanel: showFilterPanel,\n    hideFilterPanel: hideFilterPanel,\n    getVisibleRowModels: getVisibleRowModels,\n    setQuickFilterValues: setQuickFilterValues\n  };\n  useGridApiMethod(apiRef, filterApi, 'GridFilterApi');\n  /**\n   * PRE-PROCESSING\n   */\n\n  var stateExportPreProcessing = React.useCallback(function (prevState) {\n    var filterModelToExport = gridFilterModelSelector(apiRef);\n\n    if (filterModelToExport.items.length === 0 && filterModelToExport.linkOperator === getDefaultGridFilterModel().linkOperator) {\n      return prevState;\n    }\n\n    return _extends({}, prevState, {\n      filter: {\n        filterModel: filterModelToExport\n      }\n    });\n  }, [apiRef]);\n  var stateRestorePreProcessing = React.useCallback(function (params, context) {\n    var _context$stateToResto;\n\n    var filterModel = (_context$stateToResto = context.stateToRestore.filter) == null ? void 0 : _context$stateToResto.filterModel;\n\n    if (filterModel == null) {\n      return params;\n    }\n\n    apiRef.current.setState(mergeStateWithFilterModel(filterModel, props.disableMultipleColumnsFiltering, apiRef));\n    return _extends({}, params, {\n      callbacks: [].concat(_toConsumableArray(params.callbacks), [apiRef.current.unstable_applyFilters])\n    });\n  }, [apiRef, props.disableMultipleColumnsFiltering]);\n  var preferencePanelPreProcessing = React.useCallback(function (initialValue, value) {\n    if (value === GridPreferencePanelsValue.filters) {\n      var _props$componentsProp;\n\n      var FilterPanel = props.components.FilterPanel;\n      return /*#__PURE__*/_jsx(FilterPanel, _extends({}, (_props$componentsProp = props.componentsProps) == null ? void 0 : _props$componentsProp.filterPanel));\n    }\n\n    return initialValue;\n  }, [props.components.FilterPanel, (_props$componentsProp2 = props.componentsProps) == null ? void 0 : _props$componentsProp2.filterPanel]);\n  var flatFilteringMethod = React.useCallback(function (params) {\n    if (props.filterMode === GridFeatureModeConstant.client && params.isRowMatchingFilters) {\n      var rowIds = gridRowIdsSelector(apiRef);\n      var filteredRowsLookup = {};\n\n      for (var i = 0; i < rowIds.length; i += 1) {\n        var rowId = rowIds[i];\n        filteredRowsLookup[rowId] = params.isRowMatchingFilters(rowId);\n      }\n\n      return {\n        filteredRowsLookup: filteredRowsLookup,\n        // For flat tree, the `visibleRowsLookup` and the `filteredRowsLookup` since no row is collapsed.\n        visibleRowsLookup: filteredRowsLookup,\n        filteredDescendantCountLookup: {}\n      };\n    }\n\n    return {\n      visibleRowsLookup: {},\n      filteredRowsLookup: {},\n      filteredDescendantCountLookup: {}\n    };\n  }, [apiRef, props.filterMode]);\n  useGridRegisterPipeProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'preferencePanel', preferencePanelPreProcessing);\n  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, 'filtering', flatFilteringMethod);\n  /**\n   * EVENTS\n   */\n\n  var handleColumnsChange = React.useCallback(function () {\n    logger.debug('onColUpdated - GridColumns changed, applying filters');\n    var filterModel = gridFilterModelSelector(apiRef);\n    var filterableColumnsLookup = gridFilterableColumnLookupSelector(apiRef);\n    var newFilterItems = filterModel.items.filter(function (item) {\n      return item.columnField && filterableColumnsLookup[item.columnField];\n    });\n\n    if (newFilterItems.length < filterModel.items.length) {\n      apiRef.current.setFilterModel(_extends({}, filterModel, {\n        items: newFilterItems\n      }));\n    }\n  }, [apiRef, logger]);\n  var handleStrategyProcessorChange = React.useCallback(function (methodName) {\n    if (methodName === 'filtering') {\n      apiRef.current.unstable_applyFilters();\n    }\n  }, [apiRef]); // Do not call `apiRef.current.forceUpdate` to avoid re-render before updating the sorted rows.\n  // Otherwise, the state is not consistent during the render\n\n  useGridApiEventHandler(apiRef, 'rowsSet', updateFilteredRows);\n  useGridApiEventHandler(apiRef, 'rowExpansionChange', apiRef.current.unstable_applyFilters);\n  useGridApiEventHandler(apiRef, 'columnsChange', handleColumnsChange);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  /**\n   * 1ST RENDER\n   */\n\n  useFirstRender(function () {\n    apiRef.current.unstable_applyFilters();\n  });\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(function () {\n    if (props.filterModel !== undefined) {\n      apiRef.current.setFilterModel(props.filterModel);\n    }\n  }, [apiRef, logger, props.filterModel]);\n};","map":null,"metadata":{},"sourceType":"module"}