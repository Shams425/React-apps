{"ast":null,"code":"import _defineProperty from \"/home/abdallah/Documents/React-apps/DashBoard-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/home/abdallah/Documents/React-apps/DashBoard-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/abdallah/Documents/React-apps/DashBoard-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../colDef';\nimport { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nexport var COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nexport var computeColumnTypes = function computeColumnTypes() {\n  var customColumnTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var mergedColumnTypes = _extends({}, getGridDefaultColumnTypes());\n\n  Object.entries(customColumnTypes).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        colType = _ref2[0],\n        colTypeDef = _ref2[1];\n\n    if (mergedColumnTypes[colType]) {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colType], colTypeDef);\n    } else {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);\n    }\n  });\n  return mergedColumnTypes;\n};\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth(_ref3) {\n  var initialFreeSpace = _ref3.initialFreeSpace,\n      totalFlexUnits = _ref3.totalFlexUnits,\n      flexColumns = _ref3.flexColumns;\n  var flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: function freeze(field) {\n      var value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    var violationsLookup = {\n      min: {},\n      max: {}\n    };\n    var remainingFreeSpace = initialFreeSpace;\n    var flexUnits = totalFlexUnits;\n    var totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(function (field) {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (var i = 0; i < flexColumns.length; i += 1) {\n      var column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      var widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      var computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth: computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(function (field) {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(function (field) {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(function (_ref4) {\n        var field = _ref4.field;\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport var hydrateColumnsWidth = function hydrateColumnsWidth(rawState, viewportInnerWidth) {\n  var columnsLookup = {};\n  var totalFlexUnits = 0;\n  var widthAllocatedBeforeFlex = 0;\n  var flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.all.forEach(function (columnField) {\n    var newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      var computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  var initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    var computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace: initialFreeSpace,\n      totalFlexUnits: totalFlexUnits,\n      flexColumns: flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(function (field) {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\nvar columnTypeWarnedOnce = false;\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport var applyInitialState = function applyInitialState(columnsState, initialState) {\n  if (!initialState) {\n    return columnsState;\n  }\n\n  var _initialState$ordered = initialState.orderedFields,\n      orderedFields = _initialState$ordered === void 0 ? [] : _initialState$ordered,\n      _initialState$dimensi = initialState.dimensions,\n      dimensions = _initialState$dimensi === void 0 ? {} : _initialState$dimensi;\n  var columnsWithUpdatedDimensions = Object.keys(dimensions);\n\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n\n  var orderedFieldsLookup = {};\n  var cleanOrderedFields = [];\n\n  for (var i = 0; i < orderedFields.length; i += 1) {\n    var field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n\n  var newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.all : [].concat(cleanOrderedFields, _toConsumableArray(columnsState.all.filter(function (field) {\n    return !orderedFieldsLookup[field];\n  })));\n\n  var newColumnLookup = _extends({}, columnsState.lookup);\n\n  var _loop = function _loop(_i) {\n    var field = columnsWithUpdatedDimensions[_i];\n\n    var newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n\n    Object.entries(dimensions[field]).forEach(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          key = _ref6[0],\n          value = _ref6[1];\n\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  };\n\n  for (var _i = 0; _i < columnsWithUpdatedDimensions.length; _i += 1) {\n    _loop(_i);\n  }\n\n  var newColumnsState = {\n    all: newOrderedFields,\n    lookup: newColumnLookup\n  };\n  return newColumnsState;\n};\n/**\n * @deprecated Should have been internal only, you can inline the logic.\n */\n\nexport var getGridColDef = function getGridColDef(columnTypes, type) {\n  if (!type) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!columnTypeWarnedOnce && !columnTypes[type]) {\n      console.warn([\"MUI: The column type \\\"\".concat(type, \"\\\" you are using is not supported.\"), \"Column type \\\"string\\\" is being used instead.\"].join('\\n'));\n      columnTypeWarnedOnce = true;\n    }\n  }\n\n  if (!columnTypes[type]) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  return columnTypes[type];\n};\nexport var createColumnsState = function createColumnsState(_ref7) {\n  var apiRef = _ref7.apiRef,\n      columnsToUpsert = _ref7.columnsToUpsert,\n      initialState = _ref7.initialState,\n      columnTypes = _ref7.columnTypes,\n      _ref7$currentColumnVi = _ref7.currentColumnVisibilityModel,\n      currentColumnVisibilityModel = _ref7$currentColumnVi === void 0 ? gridColumnVisibilityModelSelector(apiRef) : _ref7$currentColumnVi,\n      shouldRegenColumnVisibilityModelFromColumns = _ref7.shouldRegenColumnVisibilityModelFromColumns,\n      _ref7$keepOnlyColumns = _ref7.keepOnlyColumnsToUpsert,\n      keepOnlyColumnsToUpsert = _ref7$keepOnlyColumns === void 0 ? false : _ref7$keepOnlyColumns;\n\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  var isInsideStateInitializer = !apiRef.current.state.columns;\n  var columnsStateWithoutColumnVisibilityModel;\n\n  if (isInsideStateInitializer) {\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [],\n      lookup: {}\n    };\n  } else {\n    var currentState = gridColumnsSelector(apiRef.current.state);\n    columnsStateWithoutColumnVisibilityModel = {\n      all: keepOnlyColumnsToUpsert ? [] : _toConsumableArray(currentState.all),\n      lookup: _extends({}, currentState.lookup) // Will be cleaned later if keepOnlyColumnsToUpsert=true\n\n    };\n  }\n\n  var columnsToKeep = {};\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).reduce(function (acc, key) {\n      return _extends({}, acc, _defineProperty({}, key, false));\n    }, {});\n  }\n\n  var columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(function (newColumn) {\n    var field = newColumn.field;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    var existingState = columnsStateWithoutColumnVisibilityModel.lookup[field];\n\n    if (existingState == null) {\n      // New Column\n      existingState = _extends({}, getGridColDef(columnTypes, newColumn.type), {\n        // TODO v6: Inline `getGridColDef`\n        field: field,\n        hasBeenResized: false\n      });\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    }\n\n    var hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(function (key) {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsStateWithoutColumnVisibilityModel.lookup[field] = _extends({}, existingState, {\n      hide: newColumn.hide == null ? false : newColumn.hide\n    }, newColumn, {\n      hasBeenResized: hasBeenResized\n    });\n  });\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).forEach(function (field) {\n      if (!columnsToKeep[field]) {\n        delete columnsStateWithoutColumnVisibilityModel.lookup[field];\n      }\n    });\n  }\n\n  var columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);\n\n  var columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.\n\n  var columnVisibilityModel = {};\n\n  if (shouldRegenColumnVisibilityModelFromColumns) {\n    var hasModelChanged = false;\n\n    var newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);\n\n    if (isInsideStateInitializer) {\n      columnsStateWithPreProcessing.all.forEach(function (field) {\n        newColumnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;\n      });\n    } else if (keepOnlyColumnsToUpsert) {\n      // At this point, `keepOnlyColumnsToUpsert` has a new meaning: keep the columns\n      // passed via `columnToUpsert` + columns added by the pre-processors. We do the following\n      // cleanup because a given column may have been removed from the `columns` prop but it still\n      // exists in the state.\n      Object.keys(newColumnVisibilityModel).forEach(function (field) {\n        if (!columnsStateWithPreProcessing.lookup[field]) {\n          delete newColumnVisibilityModel[field];\n          hasModelChanged = true;\n        }\n      });\n    }\n\n    columnsStateWithPreProcessing.all.forEach(function (field) {\n      // If neither the `columnsToUpsert` nor the pre-processors updated the column,\n      // Then we don't want to update the visibility status of the column in the model.\n      if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {\n        return;\n      } // We always assume that a column not in the model is visible by default. However, there's an\n      // edge case where the column is not in the model but it also doesn't exist in the `columns`\n      // prop, meaning that the column is being added. In that case, we assume that the column was\n      // not visible before for it be added to the model.\n\n\n      var isVisibleBefore = currentColumnVisibilityModel[field];\n\n      if (isVisibleBefore === undefined) {\n        if (isInsideStateInitializer) {\n          isVisibleBefore = true;\n        } else {\n          var _currentState = gridColumnsSelector(apiRef.current.state);\n\n          isVisibleBefore = !!_currentState.lookup[field];\n        }\n      }\n\n      var isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;\n\n      if (isVisibleAfter !== isVisibleBefore) {\n        hasModelChanged = true;\n        newColumnVisibilityModel[field] = isVisibleAfter;\n      }\n    });\n\n    if (hasModelChanged || isInsideStateInitializer) {\n      columnVisibilityModel = newColumnVisibilityModel;\n    } else {\n      columnVisibilityModel = currentColumnVisibilityModel;\n    }\n  } else {\n    columnVisibilityModel = currentColumnVisibilityModel;\n  }\n\n  var columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n\n  var columnsState = _extends({}, columnsStateWithPortableColumns, {\n    columnVisibilityModel: columnVisibilityModel\n  });\n\n  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport var mergeColumnsState = function mergeColumnsState(columnsState) {\n  return function (state) {\n    return _extends({}, state, {\n      columns: columnsState\n    });\n  };\n};\nexport function getFirstNonSpannedColumnToRender(_ref8) {\n  var firstColumnToRender = _ref8.firstColumnToRender,\n      apiRef = _ref8.apiRef,\n      firstRowToRender = _ref8.firstRowToRender,\n      lastRowToRender = _ref8.lastRowToRender,\n      visibleRows = _ref8.visibleRows;\n  var firstNonSpannedColumnToRender = firstColumnToRender;\n\n  for (var i = firstRowToRender; i < lastRowToRender; i += 1) {\n    var row = visibleRows[i];\n\n    if (row) {\n      var rowId = visibleRows[i].id;\n      var cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender(_ref9) {\n  var firstColumnIndex = _ref9.firstColumnIndex,\n      minColumnIndex = _ref9.minColumnIndex,\n      columnBuffer = _ref9.columnBuffer,\n      firstRowToRender = _ref9.firstRowToRender,\n      lastRowToRender = _ref9.lastRowToRender,\n      apiRef = _ref9.apiRef,\n      visibleRows = _ref9.visibleRows;\n  var initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  var firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: apiRef,\n    firstRowToRender: firstRowToRender,\n    lastRowToRender: lastRowToRender,\n    visibleRows: visibleRows\n  });\n  return firstColumnToRender;\n}","map":null,"metadata":{},"sourceType":"module"}