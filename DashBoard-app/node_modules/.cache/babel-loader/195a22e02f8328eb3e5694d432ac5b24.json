{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityRowHeightSelector, gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterStateSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortingStateSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport var rowsMetaStateInitializer = function rowsMetaStateInitializer(state) {\n  return _extends({}, state, {\n    rowsMeta: {\n      currentPageTotalHeight: 0,\n      positions: []\n    }\n  });\n};\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\n\nexport var useGridRowsMeta = function useGridRowsMeta(apiRef, props) {\n  var getRowHeight = props.getRowHeight,\n      getRowSpacing = props.getRowSpacing;\n  var rowsHeightLookup = React.useRef({});\n  var rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  var filterState = useGridSelector(apiRef, gridFilterStateSelector);\n  var paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  var sortingState = useGridSelector(apiRef, gridSortingStateSelector);\n  var currentPage = useGridVisibleRows(apiRef, props);\n  var hydrateRowsMeta = React.useCallback(function () {\n    apiRef.current.setState(function (state) {\n      var positions = [];\n      var densityFactor = gridDensityFactorSelector(state, apiRef.current.instanceId);\n      var currentRowHeight = gridDensityRowHeightSelector(state, apiRef.current.instanceId);\n      var currentPageTotalHeight = currentPage.rows.reduce(function (acc, row) {\n        positions.push(acc);\n        var baseRowHeight;\n        var isResized = rowsHeightLookup.current[row.id] && rowsHeightLookup.current[row.id].isResized || false;\n\n        if (isResized) {\n          // do not recalculate resized row height and use the value from the lookup\n          baseRowHeight = rowsHeightLookup.current[row.id].value;\n        } else {\n          baseRowHeight = currentRowHeight;\n\n          if (getRowHeight) {\n            var _getRowHeight; // Default back to base rowHeight if getRowHeight returns null or undefined.\n\n\n            baseRowHeight = (_getRowHeight = getRowHeight(_extends({}, row, {\n              densityFactor: densityFactor\n            }))) != null ? _getRowHeight : currentRowHeight;\n          }\n        } // We use an object to make simple to check if a height is already added or not\n\n\n        var initialHeights = {\n          base: baseRowHeight\n        };\n\n        if (getRowSpacing) {\n          var _spacing$top, _spacing$bottom;\n\n          var indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n          var spacing = getRowSpacing(_extends({}, row, {\n            isFirstVisible: indexRelativeToCurrentPage === 0,\n            isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n            indexRelativeToCurrentPage: indexRelativeToCurrentPage\n          }));\n          initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n          initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n        }\n\n        var sizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n        var finalRowHeight = Object.values(sizes).reduce(function (acc2, value) {\n          return acc2 + value;\n        }, 0);\n        rowsHeightLookup.current[row.id] = {\n          value: baseRowHeight,\n          sizes: sizes,\n          isResized: isResized\n        };\n        return acc + finalRowHeight;\n      }, 0);\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight: currentPageTotalHeight,\n          positions: positions\n        }\n      });\n    });\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, getRowSpacing, getRowHeight]);\n\n  var getTargetRowHeight = function getTargetRowHeight(rowId) {\n    var _rowsHeightLookup$cur;\n\n    return ((_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.value) || rowHeight;\n  };\n\n  var getRowInternalSizes = function getRowInternalSizes(rowId) {\n    var _rowsHeightLookup$cur2;\n\n    return (_rowsHeightLookup$cur2 = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur2.sizes;\n  };\n\n  var setRowHeight = React.useCallback(function (id, height) {\n    rowsHeightLookup.current[id] = {\n      value: height,\n      isResized: true,\n      sizes: _extends({}, rowsHeightLookup.current[id].sizes, {\n        base: height\n      })\n    };\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n\n  React.useEffect(function () {\n    hydrateRowsMeta();\n  }, [rowHeight, filterState, paginationState, sortingState, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  var rowsMetaApi = {\n    unstable_getRowHeight: getTargetRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'GridRowsMetaApi');\n};","map":null,"metadata":{},"sourceType":"module"}