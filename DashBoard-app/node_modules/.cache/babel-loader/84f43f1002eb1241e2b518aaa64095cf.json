{"ast":null,"code":"import _toConsumableArray from \"/home/abdallah/Documents/React-apps/DashBoard-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridFeatureModeConstant } from '../../../models/gridFeatureMode';\nimport { isEnterKey } from '../../../utils/keyboardUtils';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridColumnLookupSelector } from '../columns/gridColumnsSelector';\nimport { gridSortedRowEntriesSelector, gridSortedRowIdsSelector, gridSortModelSelector } from './gridSortingSelector';\nimport { gridRowIdsSelector, gridRowTreeSelector } from '../rows';\nimport { useFirstRender } from '../../utils/useFirstRender';\nimport { useGridRegisterStrategyProcessor, GRID_DEFAULT_STRATEGY } from '../../core/strategyProcessing';\nimport { buildAggregatedSortingApplier, mergeStateWithSortModel, getNextGridSortDirection, sanitizeSortModel } from './gridSortingUtils';\nimport { useGridRegisterPipeProcessor } from '../../core/pipeProcessing';\nexport var sortingStateInitializer = function sortingStateInitializer(state, props) {\n  var _ref, _props$sortModel, _props$initialState, _props$initialState$s;\n\n  var sortModel = (_ref = (_props$sortModel = props.sortModel) != null ? _props$sortModel : (_props$initialState = props.initialState) == null ? void 0 : (_props$initialState$s = _props$initialState.sorting) == null ? void 0 : _props$initialState$s.sortModel) != null ? _ref : [];\n  return _extends({}, state, {\n    sorting: {\n      sortModel: sanitizeSortModel(sortModel, props.disableMultipleColumnsSorting),\n      sortedRows: []\n    }\n  });\n};\n/**\n * @requires useGridRows (event)\n * @requires useGridColumns (event)\n */\n\nexport var useGridSorting = function useGridSorting(apiRef, props) {\n  var logger = useGridLogger(apiRef, 'useGridSorting');\n  apiRef.current.unstable_updateControlState({\n    stateId: 'sortModel',\n    propModel: props.sortModel,\n    propOnChange: props.onSortModelChange,\n    stateSelector: gridSortModelSelector,\n    changeEvent: 'sortModelChange'\n  });\n  var upsertSortModel = React.useCallback(function (field, sortItem) {\n    var sortModel = gridSortModelSelector(apiRef);\n    var existingIdx = sortModel.findIndex(function (c) {\n      return c.field === field;\n    });\n\n    var newSortModel = _toConsumableArray(sortModel);\n\n    if (existingIdx > -1) {\n      if (!sortItem) {\n        newSortModel.splice(existingIdx, 1);\n      } else {\n        newSortModel.splice(existingIdx, 1, sortItem);\n      }\n    } else {\n      newSortModel = [].concat(_toConsumableArray(sortModel), [sortItem]);\n    }\n\n    return newSortModel;\n  }, [apiRef]);\n  var createSortItem = React.useCallback(function (col, directionOverride) {\n    var _col$sortingOrder2;\n\n    var sortModel = gridSortModelSelector(apiRef);\n    var existing = sortModel.find(function (c) {\n      return c.field === col.field;\n    });\n\n    if (existing) {\n      var _col$sortingOrder;\n\n      var nextSort = directionOverride === undefined ? getNextGridSortDirection((_col$sortingOrder = col.sortingOrder) != null ? _col$sortingOrder : props.sortingOrder, existing.sort) : directionOverride;\n      return nextSort == null ? undefined : _extends({}, existing, {\n        sort: nextSort\n      });\n    }\n\n    return {\n      field: col.field,\n      sort: directionOverride === undefined ? getNextGridSortDirection((_col$sortingOrder2 = col.sortingOrder) != null ? _col$sortingOrder2 : props.sortingOrder) : directionOverride\n    };\n  }, [apiRef, props.sortingOrder]);\n  /**\n   * API METHODS\n   */\n\n  var applySorting = React.useCallback(function () {\n    apiRef.current.setState(function (state) {\n      if (props.sortingMode === GridFeatureModeConstant.server) {\n        logger.debug('Skipping sorting rows as sortingMode = server');\n        return _extends({}, state, {\n          sorting: _extends({}, state.sorting, {\n            sortedRows: gridRowIdsSelector(state, apiRef.current.instanceId)\n          })\n        });\n      }\n\n      var sortModel = gridSortModelSelector(state, apiRef.current.instanceId);\n      var sortRowList = buildAggregatedSortingApplier(sortModel, apiRef);\n      var sortedRows = apiRef.current.unstable_applyStrategyProcessor('sorting', {\n        sortRowList: sortRowList\n      });\n      return _extends({}, state, {\n        sorting: _extends({}, state.sorting, {\n          sortedRows: sortedRows\n        })\n      });\n    });\n    apiRef.current.publishEvent('sortedRowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef, logger, props.sortingMode]);\n  var setSortModel = React.useCallback(function (model) {\n    var currentModel = gridSortModelSelector(apiRef);\n\n    if (currentModel !== model) {\n      logger.debug(\"Setting sort model\");\n      apiRef.current.setState(mergeStateWithSortModel(model, props.disableMultipleColumnsSorting));\n      apiRef.current.forceUpdate();\n      apiRef.current.applySorting();\n    }\n  }, [apiRef, logger, props.disableMultipleColumnsSorting]);\n  var sortColumn = React.useCallback(function (column, direction, allowMultipleSorting) {\n    if (!column.sortable) {\n      return;\n    }\n\n    var sortItem = createSortItem(column, direction);\n    var sortModel;\n\n    if (!allowMultipleSorting || props.disableMultipleColumnsSorting) {\n      sortModel = !sortItem ? [] : [sortItem];\n    } else {\n      sortModel = upsertSortModel(column.field, sortItem);\n    }\n\n    apiRef.current.setSortModel(sortModel);\n  }, [apiRef, upsertSortModel, createSortItem, props.disableMultipleColumnsSorting]);\n  var getSortModel = React.useCallback(function () {\n    return gridSortModelSelector(apiRef);\n  }, [apiRef]);\n  var getSortedRows = React.useCallback(function () {\n    var sortedRows = gridSortedRowEntriesSelector(apiRef);\n    return sortedRows.map(function (row) {\n      return row.model;\n    });\n  }, [apiRef]);\n  var getSortedRowIds = React.useCallback(function () {\n    return gridSortedRowIdsSelector(apiRef);\n  }, [apiRef]);\n  var getRowIndex = React.useCallback(function (id) {\n    return apiRef.current.getSortedRowIds().indexOf(id);\n  }, [apiRef]);\n  var getRowIdFromRowIndex = React.useCallback(function (index) {\n    return apiRef.current.getSortedRowIds()[index];\n  }, [apiRef]);\n  var sortApi = {\n    getSortModel: getSortModel,\n    getSortedRows: getSortedRows,\n    getSortedRowIds: getSortedRowIds,\n    getRowIndex: getRowIndex,\n    getRowIdFromRowIndex: getRowIdFromRowIndex,\n    setSortModel: setSortModel,\n    sortColumn: sortColumn,\n    applySorting: applySorting\n  };\n  useGridApiMethod(apiRef, sortApi, 'GridSortApi');\n  /**\n   * PRE-PROCESSING\n   */\n\n  var stateExportPreProcessing = React.useCallback(function (prevState) {\n    var sortModelToExport = gridSortModelSelector(apiRef);\n\n    if (sortModelToExport.length === 0) {\n      return prevState;\n    }\n\n    return _extends({}, prevState, {\n      sorting: {\n        sortModel: sortModelToExport\n      }\n    });\n  }, [apiRef]);\n  var stateRestorePreProcessing = React.useCallback(function (params, context) {\n    var _context$stateToResto;\n\n    var sortModel = (_context$stateToResto = context.stateToRestore.sorting) == null ? void 0 : _context$stateToResto.sortModel;\n\n    if (sortModel == null) {\n      return params;\n    }\n\n    apiRef.current.setState(mergeStateWithSortModel(sortModel, props.disableMultipleColumnsSorting));\n    return _extends({}, params, {\n      callbacks: [].concat(_toConsumableArray(params.callbacks), [apiRef.current.applySorting])\n    });\n  }, [apiRef, props.disableMultipleColumnsSorting]);\n  var flatSortingMethod = React.useCallback(function (params) {\n    if (!params.sortRowList) {\n      return gridRowIdsSelector(apiRef);\n    }\n\n    var rowTree = gridRowTreeSelector(apiRef);\n    return params.sortRowList(Object.values(rowTree));\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, 'sorting', flatSortingMethod);\n  /**\n   * EVENTS\n   */\n\n  var handleColumnHeaderClick = React.useCallback(function (_ref2, event) {\n    var colDef = _ref2.colDef;\n    var allowMultipleSorting = event.shiftKey || event.metaKey || event.ctrlKey;\n    sortColumn(colDef, undefined, allowMultipleSorting);\n  }, [sortColumn]);\n  var handleColumnHeaderKeyDown = React.useCallback(function (_ref3, event) {\n    var colDef = _ref3.colDef;\n\n    // Ctrl + Enter opens the column menu\n    if (isEnterKey(event.key) && !event.ctrlKey && !event.metaKey) {\n      sortColumn(colDef, undefined, event.shiftKey);\n    }\n  }, [sortColumn]);\n  var handleColumnsChange = React.useCallback(function () {\n    // When the columns change we check that the sorted columns are still part of the dataset\n    var sortModel = gridSortModelSelector(apiRef);\n    var latestColumns = gridColumnLookupSelector(apiRef);\n\n    if (sortModel.length > 0) {\n      var newModel = sortModel.filter(function (sortItem) {\n        return latestColumns[sortItem.field];\n      });\n\n      if (newModel.length < sortModel.length) {\n        apiRef.current.setSortModel(newModel);\n      }\n    }\n  }, [apiRef]);\n  var handleStrategyProcessorChange = React.useCallback(function (methodName) {\n    if (methodName === 'sorting') {\n      apiRef.current.applySorting();\n    }\n  }, [apiRef]);\n  useGridApiEventHandler(apiRef, 'columnHeaderClick', handleColumnHeaderClick);\n  useGridApiEventHandler(apiRef, 'columnHeaderKeyDown', handleColumnHeaderKeyDown);\n  useGridApiEventHandler(apiRef, 'rowsSet', apiRef.current.applySorting);\n  useGridApiEventHandler(apiRef, 'columnsChange', handleColumnsChange);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  /**\n   * 1ST RENDER\n   */\n\n  useFirstRender(function () {\n    apiRef.current.applySorting();\n  });\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(function () {\n    if (props.sortModel !== undefined) {\n      apiRef.current.setSortModel(props.sortModel);\n    }\n  }, [apiRef, props.sortModel]);\n};","map":null,"metadata":{},"sourceType":"module"}