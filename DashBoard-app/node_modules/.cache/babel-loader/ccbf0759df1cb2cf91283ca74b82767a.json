{"ast":null,"code":"import _slicedToArray from \"/home/abdallah/Documents/React-apps/DashBoard-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { defaultMemoize } from 'reselect';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridTabIndexColumnHeaderSelector, gridTabIndexCellSelector, gridFocusColumnHeaderSelector } from '../focus/gridFocusStateSelector';\nimport { gridDensityHeaderHeightSelector } from '../density/densitySelector';\nimport { gridFilterActiveItemsLookupSelector } from '../filter/gridFilterSelector';\nimport { gridSortColumnLookupSelector } from '../sorting/gridSortingSelector';\nimport { gridColumnMenuSelector } from '../columnMenu/columnMenuSelector';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { GridColumnHeaderItem } from '../../../components/columnHeaders/GridColumnHeaderItem';\nimport { getFirstColumnIndexToRender } from '../columns/gridColumnsUtils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { getRenderableIndexes } from '../virtualization/useGridVirtualScroller';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction isUIEvent(event) {\n  return !!event.target;\n}\n\nexport var useGridColumnHeaders = function useGridColumnHeaders(props) {\n  var innerRefProp = props.innerRef,\n      _props$minColumnIndex = props.minColumnIndex,\n      minColumnIndex = _props$minColumnIndex === void 0 ? 0 : _props$minColumnIndex;\n\n  var _React$useState = React.useState(''),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      dragCol = _React$useState2[0],\n      setDragCol = _React$useState2[1];\n\n  var _React$useState3 = React.useState(''),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      resizeCol = _React$useState4[0],\n      setResizeCol = _React$useState4[1];\n\n  var apiRef = useGridApiContext();\n  var visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  var columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  var tabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);\n  var cellTabIndexState = useGridSelector(apiRef, gridTabIndexCellSelector);\n  var columnHeaderFocus = useGridSelector(apiRef, gridFocusColumnHeaderSelector);\n  var headerHeight = useGridSelector(apiRef, gridDensityHeaderHeightSelector);\n  var filterColumnLookup = useGridSelector(apiRef, gridFilterActiveItemsLookupSelector);\n  var sortColumnLookup = useGridSelector(apiRef, gridSortColumnLookupSelector);\n  var columnMenuState = useGridSelector(apiRef, gridColumnMenuSelector);\n  var rootProps = useGridRootProps();\n  var innerRef = React.useRef(null);\n  var handleInnerRef = useForkRef(innerRefProp, innerRef);\n\n  var _React$useState5 = React.useState(null),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      renderContext = _React$useState6[0],\n      setRenderContext = _React$useState6[1];\n\n  var prevRenderContext = React.useRef(renderContext);\n  var prevScrollLeft = React.useRef(0);\n  var currentPage = useGridVisibleRows(apiRef, rootProps);\n  React.useEffect(function () {\n    apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;\n  }, [apiRef]); // memoize `getFirstColumnIndexToRender`, since it's called on scroll\n\n  var getFirstColumnIndexToRenderRef = React.useRef(defaultMemoize(getFirstColumnIndexToRender, {\n    equalityCheck: function equalityCheck(a, b) {\n      return ['firstColumnIndex', 'minColumnIndex', 'columnBuffer'].every(function (key) {\n        return a[key] === b[key];\n      });\n    }\n  }));\n  var updateInnerPosition = React.useCallback(function (nextRenderContext) {\n    var _getRenderableIndexes = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    }),\n        _getRenderableIndexes2 = _slicedToArray(_getRenderableIndexes, 2),\n        firstRowToRender = _getRenderableIndexes2[0],\n        lastRowToRender = _getRenderableIndexes2[1];\n\n    var firstColumnToRender = getFirstColumnIndexToRenderRef.current({\n      firstColumnIndex: nextRenderContext.firstColumnIndex,\n      minColumnIndex: minColumnIndex,\n      columnBuffer: rootProps.columnBuffer,\n      firstRowToRender: firstRowToRender,\n      lastRowToRender: lastRowToRender,\n      apiRef: apiRef,\n      visibleRows: currentPage.rows\n    });\n    var offset = firstColumnToRender > 0 ? prevScrollLeft.current - columnPositions[firstColumnToRender] : prevScrollLeft.current;\n    innerRef.current.style.transform = \"translate3d(\".concat(-offset, \"px, 0px, 0px)\");\n  }, [columnPositions, minColumnIndex, rootProps.columnBuffer, apiRef, currentPage.rows, rootProps.rowBuffer]);\n  React.useLayoutEffect(function () {\n    if (renderContext) {\n      updateInnerPosition(renderContext);\n    }\n  }, [renderContext, updateInnerPosition]);\n  var handleScroll = React.useCallback(function (_ref, event) {\n    var left = _ref.left,\n        _ref$renderContext = _ref.renderContext,\n        nextRenderContext = _ref$renderContext === void 0 ? null : _ref$renderContext;\n\n    var _prevRenderContext$cu, _prevRenderContext$cu2;\n\n    if (!innerRef.current) {\n      return;\n    } // Ignore vertical scroll.\n    // Excepts the first event which sets the previous render context.\n\n\n    if (prevScrollLeft.current === left && ((_prevRenderContext$cu = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu.firstColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.firstColumnIndex) && ((_prevRenderContext$cu2 = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu2.lastColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.lastColumnIndex)) {\n      return;\n    }\n\n    prevScrollLeft.current = left; // We can only update the position when we guarantee that the render context has been\n    // rendered. This is achieved using ReactDOM.flushSync or when the context doesn't change.\n\n    var canUpdateInnerPosition = false;\n\n    if (nextRenderContext !== prevRenderContext.current || !prevRenderContext.current) {\n      // ReactDOM.flushSync cannot be called on `scroll` events fired inside effects\n      if (isUIEvent(event)) {\n        // To prevent flickering, the inner position can only be updated after the new context has\n        // been rendered. ReactDOM.flushSync ensures that the state changes will happen before\n        // updating the position.\n        ReactDOM.flushSync(function () {\n          setRenderContext(nextRenderContext);\n        });\n        canUpdateInnerPosition = true;\n      } else {\n        setRenderContext(nextRenderContext);\n      }\n\n      prevRenderContext.current = nextRenderContext;\n    } else {\n      canUpdateInnerPosition = true;\n    } // Pass directly the render context to avoid waiting for the next render\n\n\n    if (nextRenderContext && canUpdateInnerPosition) {\n      updateInnerPosition(nextRenderContext);\n    }\n  }, [updateInnerPosition]);\n  var handleColumnResizeStart = React.useCallback(function (params) {\n    return setResizeCol(params.field);\n  }, []);\n  var handleColumnResizeStop = React.useCallback(function () {\n    return setResizeCol('');\n  }, []);\n  var handleColumnReorderStart = React.useCallback(function (params) {\n    return setDragCol(params.field);\n  }, []);\n  var handleColumnReorderStop = React.useCallback(function () {\n    return setDragCol('');\n  }, []);\n  useGridApiEventHandler(apiRef, 'columnResizeStart', handleColumnResizeStart);\n  useGridApiEventHandler(apiRef, 'columnResizeStop', handleColumnResizeStop);\n  useGridApiEventHandler(apiRef, 'columnHeaderDragStart', handleColumnReorderStart);\n  useGridApiEventHandler(apiRef, 'columnHeaderDragEnd', handleColumnReorderStop);\n  useGridApiEventHandler(apiRef, 'rowsScroll', handleScroll);\n\n  var getColumns = function getColumns(params) {\n    var other = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _ref2 = params || {},\n        _ref2$renderContext = _ref2.renderContext,\n        nextRenderContext = _ref2$renderContext === void 0 ? renderContext : _ref2$renderContext,\n        _ref2$minFirstColumn = _ref2.minFirstColumn,\n        minFirstColumn = _ref2$minFirstColumn === void 0 ? minColumnIndex : _ref2$minFirstColumn,\n        _ref2$maxLastColumn = _ref2.maxLastColumn,\n        maxLastColumn = _ref2$maxLastColumn === void 0 ? visibleColumns.length : _ref2$maxLastColumn;\n\n    if (!nextRenderContext) {\n      return null;\n    }\n\n    var columns = [];\n\n    var _getRenderableIndexes3 = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    }),\n        _getRenderableIndexes4 = _slicedToArray(_getRenderableIndexes3, 2),\n        firstRowToRender = _getRenderableIndexes4[0],\n        lastRowToRender = _getRenderableIndexes4[1];\n\n    var firstColumnToRender = getFirstColumnIndexToRenderRef.current({\n      firstColumnIndex: nextRenderContext.firstColumnIndex,\n      minColumnIndex: minFirstColumn,\n      columnBuffer: rootProps.columnBuffer,\n      apiRef: apiRef,\n      firstRowToRender: firstRowToRender,\n      lastRowToRender: lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    var lastColumnToRender = Math.min(nextRenderContext.lastColumnIndex + rootProps.columnBuffer, maxLastColumn);\n    var renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n\n    for (var i = 0; i < renderedColumns.length; i += 1) {\n      var column = renderedColumns[i];\n      var columnIndex = firstColumnToRender + i;\n      var isFirstColumn = columnIndex === 0;\n      var hasTabbableElement = !(tabIndexState === null && cellTabIndexState === null);\n      var tabIndex = tabIndexState !== null && tabIndexState.field === column.field || isFirstColumn && !hasTabbableElement ? 0 : -1;\n      var hasFocus = columnHeaderFocus !== null && columnHeaderFocus.field === column.field;\n      var open = columnMenuState.open && columnMenuState.field === column.field;\n      columns.push( /*#__PURE__*/_jsx(GridColumnHeaderItem, _extends({}, sortColumnLookup[column.field], {\n        columnMenuOpen: open,\n        filterItemsCounter: filterColumnLookup[column.field] && filterColumnLookup[column.field].length,\n        headerHeight: headerHeight,\n        isDragging: column.field === dragCol,\n        column: column,\n        colIndex: columnIndex,\n        isResizing: resizeCol === column.field,\n        isLastColumn: columnIndex === visibleColumns.length - 1,\n        extendRowFullWidth: !rootProps.disableExtendRowFullWidth,\n        hasFocus: hasFocus,\n        tabIndex: tabIndex\n      }, other), column.field));\n    }\n\n    return columns;\n  };\n\n  var rootStyle = {\n    minHeight: headerHeight,\n    maxHeight: headerHeight,\n    lineHeight: \"\".concat(headerHeight, \"px\")\n  };\n  return {\n    renderContext: renderContext,\n    getColumns: getColumns,\n    isDragging: !!dragCol,\n    getRootProps: function getRootProps() {\n      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _extends({\n        style: rootStyle\n      }, other);\n    },\n    getInnerProps: function getInnerProps() {\n      return {\n        ref: handleInnerRef,\n        'aria-rowindex': 1,\n        role: 'row'\n      };\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module"}