{"ast":null,"code":"import React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\n/**\n * @requires useGridColumns (method, event)\n * @requires useGridParamsApi (method)\n */\n\nexport var useGridColumnSpanning = function useGridColumnSpanning(apiRef) {\n  var lookup = React.useRef({});\n  var setCellColSpanInfo = React.useCallback(function (rowId, columnIndex, cellColSpanInfo) {\n    var sizes = lookup.current;\n\n    if (!sizes[rowId]) {\n      sizes[rowId] = {};\n    }\n\n    sizes[rowId][columnIndex] = cellColSpanInfo;\n  }, []);\n  var getCellColSpanInfo = React.useCallback(function (rowId, columnIndex) {\n    var _lookup$current$rowId;\n\n    return (_lookup$current$rowId = lookup.current[rowId]) == null ? void 0 : _lookup$current$rowId[columnIndex];\n  }, []); // Calculate `colSpan` for the cell.\n\n  var calculateCellColSpan = React.useCallback(function (params) {\n    var columnIndex = params.columnIndex,\n        rowId = params.rowId,\n        minFirstColumnIndex = params.minFirstColumnIndex,\n        maxLastColumnIndex = params.maxLastColumnIndex;\n    var visibleColumns = apiRef.current.getVisibleColumns();\n    var columnsLength = visibleColumns.length;\n    var column = visibleColumns[columnIndex];\n    var colSpan = typeof column.colSpan === 'function' ? column.colSpan(apiRef.current.getCellParams(rowId, column.field)) : column.colSpan;\n\n    if (!colSpan || colSpan === 1) {\n      setCellColSpanInfo(rowId, columnIndex, {\n        spannedByColSpan: false,\n        cellProps: {\n          colSpan: 1,\n          width: column.computedWidth\n        }\n      });\n      return {\n        colSpan: 1\n      };\n    }\n\n    var width = column.computedWidth;\n\n    for (var j = 1; j < colSpan; j += 1) {\n      var nextColumnIndex = columnIndex + j; // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n\n      if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n        var nextColumn = visibleColumns[nextColumnIndex];\n        width += nextColumn.computedWidth;\n        setCellColSpanInfo(rowId, columnIndex + j, {\n          spannedByColSpan: true,\n          rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n          leftVisibleCellIndex: columnIndex\n        });\n      }\n\n      setCellColSpanInfo(rowId, columnIndex, {\n        spannedByColSpan: false,\n        cellProps: {\n          colSpan: colSpan,\n          width: width\n        }\n      });\n    }\n\n    return {\n      colSpan: colSpan\n    };\n  }, [apiRef, setCellColSpanInfo]); // Calculate `colSpan` for each cell in the row\n\n  var calculateColSpan = React.useCallback(function (_ref) {\n    var rowId = _ref.rowId,\n        minFirstColumn = _ref.minFirstColumn,\n        maxLastColumn = _ref.maxLastColumn;\n\n    for (var i = minFirstColumn; i < maxLastColumn; i += 1) {\n      var cellProps = calculateCellColSpan({\n        columnIndex: i,\n        rowId: rowId,\n        minFirstColumnIndex: minFirstColumn,\n        maxLastColumnIndex: maxLastColumn\n      });\n\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  }, [calculateCellColSpan]);\n  var columnSpanningApi = {\n    unstable_getCellColSpanInfo: getCellColSpanInfo,\n    unstable_calculateColSpan: calculateColSpan\n  };\n  useGridApiMethod(apiRef, columnSpanningApi, 'GridColumnSpanningAPI');\n  var handleColumnReorderChange = React.useCallback(function () {\n    // `colSpan` needs to be recalculated after column reordering\n    lookup.current = {};\n  }, []);\n  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnReorderChange);\n};","map":null,"metadata":{},"sourceType":"module"}